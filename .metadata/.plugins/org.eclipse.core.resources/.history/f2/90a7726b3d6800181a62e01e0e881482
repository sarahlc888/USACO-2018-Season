import java.io.*;
import java.util.*;
/*
 * USACO 2016 January Contest, Gold
 * Problem 1. Angry Cows
 * 
 * week of 6/4/18
 * 
 * Binary search 1 for the smallest radius R that will work
 * Within search 1, search for any starting point that works
 * 
 * uses long and multiplies everything by 10
 * but doesn't work bc of stack overflow errors
 * 
 * convert modbsearch functions to while loops
 */
public class AngryCows4 {
	public static long[] hay;
	
	public static void main(String args[]) throws IOException {

		//BufferedReader br = new BufferedReader(new FileReader("angry.in"));
		BufferedReader br = new BufferedReader(new FileReader("testData/2.in"));
		
		int N = Integer.parseInt(br.readLine()); // number of haybales
		hay = new long[N]; // holds positions of the haybales
		
		for (int i = 0; i < N; i++) { // loop through, multiply everything by 10 to get rid of decimals
			hay[i] = Long.parseLong(br.readLine()) * 10;
		}
		br.close();
		Arrays.sort(hay);
		
		// binary search for the radius
		long loR = 0; // lowest possible radius
		long hiR = hay[hay.length-1]-hay[0]; // highest possible radius
		
		long ret = -1;
		
		while (loR < hiR) {
			System.out.println("s1");
			System.out.println("loR : " + loR + " hiR: " + hiR);
			//long loX = hay[0]; // lowest possible starting point
			//long hiX = hay[hay.length-1]; // highest possible starting point
			
			if (bSearchModX(hay[hay.length-1], hay[0], hiR, loR, loR)) {
				System.out.println("HERE1");
				ret = loR;
				break;
			} else if (!bSearchModX(hay[hay.length-1], hay[0], hiR, loR, hiR)) {
				System.out.println("HERE2");
				ret = -1;
				break;
			} else if (hiR - loR == 1) {
				System.out.println("HERE3");
				ret = hiR;
				break;
			}
			
			long midR = (loR + hiR) / 2; // current R
			if (bSearchModX(hay[hay.length-1], hay[0], hiR, loR, midR)) {
				hiR = midR;
			} else {
				loR = midR + 1;
			}
			System.out.println("e1");
		}

		System.out.println(ret);

		System.out.println(loR);
		
		PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("angry.out")));
		pw.println(loR);
		pw.close();
	}
	public static boolean bSearchModX(long hiX, long loX, long hiR, long loR, long midR) {
		System.out.println("  start X");
		boolean ret = false;
		while (loX < hiX) {
			System.out.println("here");
			long midX = (loX + hiX)/2; // current X

			boolean right = rightWorks(midX, midR);
			boolean left = leftWorks(midX, midR);
				
			if (right && left) { // current X and R are valid
				ret = true;
				break;
			} else if (right) { // only right side works
				hiX = midX; // update X range
			} else if (left) { // only left side works
				loX = midX; // update X range
			} else { // neither side works
				ret = false;
				break;
			}
		}
		System.out.println("  end X");
		return ret;
	}
	public static long leftBound(long X, long R) { // returns pos of leftmost cow reachable in one explosion chain
		System.out.println("    lb  X: " + X + " R: " + R );
		
		long curX = X;
		long curR = R;
		
		while (true) {
			// break if there is no more radius left or if the blast has reached the leftmost cow
			if (curR <= 0 || curX <= hay[0]) break; 
			
			int nextStart = leftMost(X, R); // left-most cow reachable in current blast

			if (nextStart == -1 || hay[nextStart] >= curX) break; // if the next one isn't further left
			
			curX = hay[nextStart]; // decrease curX
			curR -= 10; // reduce radius
		}

		return curX;

	}
	public static long rightBound(long X, long R) { // returns pos of rightmost cow reachable in one explosion chain
		System.out.println("    rb  X: " + X + "  R: " + R);
		
		long curX = X;
		long curR = R;
		
		while (true) {
			// break if there is no more radius left or if the blast has reached the rightmost cow
			if (curR <= 0 || curX >= hay[hay.length-1]) break; 
			
			int nextStart = rightMost(X, R); // right-most cow reachable in current blast

			if (nextStart == -1 || hay[nextStart] <= curX) break; // if the next one isn't further right
			
			curX = hay[nextStart]; // increase curX
			curR -= 10; // reduce radius
		}

		return curX;
	}
	
	public static int leftMost(long X, long R) { 
		// returns index of leftmost cow reachable in one section of an explosion
		int lo = 0;
		int hi = hay.length-1;
		int ret = -1;
		
		while (lo < hi) {
			if (hay[lo] >= X - R) { // if lo is in range
				ret = lo;
				break;
			}
			if (hay[hi] < X - R) { // if even hi is NOT in range
				ret = -1;
				break;
			}
			if (hi - lo == 1) return hi; // bc it's the only option left
			int mid = (lo + hi)/2;
			
			if (hay[mid] >= X - R) { // if mid is in range
				hi = mid;
			} else { // mid is not in range
				lo = mid + 1;
			}
		}
		return ret;
	}
	public static int rightMost(long X, long R) { 
		// returns index of rightmost cow reachable in one section of an explosion
		int lo = 0;
		int hi = hay.length-1;
		int ret = -1;
		
		while (lo < hi) {
			if (hay[hi] <= X + R) { // if hi is in range
				ret = lo;
				break;
			}
			if (hay[lo] > X + R) { // if even lo is NOT in range
				ret = -1;
				break;
			}
			if (hi - lo == 1) return lo; // bc it's the only option left
			int mid = (lo + hi)/2;
			
			if (hay[mid] <= X + R) { // if mid is in range
				lo = mid;
			} else { // mid is not in range
				hi = mid - 1;
			}
		}
		return ret;
	}

	public static boolean rightWorks(long X, long R) {
		return rightBound(X, R) >= hay[hay.length-1];
	}
	public static boolean leftWorks(long X, long R) {
		return leftBound(X, R) <= hay[0];
	}
	
	
}
